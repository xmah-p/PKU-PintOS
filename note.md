# run

/bin/sh: 1: ../../tests/make-grade: not found

é¦–å…ˆå°† src/tests/make-grade æ”¹æˆ LF

: open: No such file or directory

æ³¨æ„éœ€è¦å…ˆ make clean ç„¶åå† make grade å¦åˆ™ up to date

ä¿®æ”¹ src/tests/threads/Grading, src/tests/threads/Rubric.foo

```bash
docker run -it --rm --name pintos --mount type=bind,source=D:/wksp/pintos,target=/home/PKUOS/pintos pkuflyingpig/pintos bash

cd pintos/src/threads/; make

cd build;

# æˆ–è€…
cd pintos/src/threads/build

pintos --gdb --   # debug

make tests/threads/alarm-priority.result   
rm tests/userprog/sc-boundary-3.output; make tests/userprog/sc-boundary-3.result # test a certain case

make check > ~/pintos/check.txt  # run all tests
make grade > ~/pintos/grade.txt  # run all tests and grade

```

å¼€ä¸€ä¸ªæ–°ç»ˆç«¯

```bash
docker exec -it pintos bash

cd pintos/src/threads/build; pintos-gdb kernel.o

debugpintos
```

å¦‚æœè¿™ä¸€æ­¥ç½‘ç»œä¸é€šï¼Œctrl+a+x ç¬¬ä¸€ä¸ªç»ˆç«¯çš„ qemu

b *0x7c00

load_kernel
b *0x7c7e    

ctrl+leftarrow å¡æ­»


# Lab 1

assertion failure in thread_current(), which checks that
   the `magic' member of the running thread's `struct thread' is
   set to THREAD_MAGIC.  Stack overflow will normally change this
   value, triggering the assertion

åœ°å€è®¡ç®—ï¼št->stack = (uint8_t *) t + PGSIZE

   If thread_start() has been called, then the new thread may be
   scheduled before thread_create() returns.  It could even exit
   before thread_create() returns.  Contrariwise, the original
   thread may run for any amount of time before the new thread is
   scheduled.  Use a semaphore or some other form of
   synchronization if you need to ensure ordering.

   ç¦ç”¨ä¸­æ–­è‡³ schedule() å®Œæˆ	ç¡®ä¿è°ƒåº¦å†³ç­–å’Œä¸Šä¸‹æ–‡åˆ‡æ¢çš„åŸå­æ€§ï¼Œé¿å…ä¸­æ–­å¹²æ‰°ã€‚
åœ¨ schedule() åæ¢å¤ä¸­æ–­	æ¢å¤çš„æ˜¯åŸçº¿ç¨‹çš„ä¸­æ–­çŠ¶æ€ï¼Œä¸”ä»…åœ¨åŸçº¿ç¨‹é‡æ–°æ‰§è¡Œæ—¶ç”Ÿæ•ˆï¼Œä¸å½±å“æ–°çº¿ç¨‹çš„ä¸­æ–­ç¯å¢ƒã€‚
è¿™ä¸€è®¾è®¡ä¿éšœäº†çº¿ç¨‹è°ƒåº¦çš„å¯é æ€§å’Œæ“ä½œç³»ç»Ÿçš„ç¨³å®šæ€§ï¼Œæ˜¯å†…æ ¸ç¼–ç¨‹ä¸­åŒæ­¥æ§åˆ¶çš„ç»å…¸å®è·µã€‚

é¡ºåºï¼š

1. 1.1
2. 2.1: basic priority scheduling
3. 3.1: fixed-point real arithmetic
4. å®Œå–„ 2.1
5. å‰©ä½™

You need to decide where to check whether the elapsed time exceeded the sleep time.

## Alarm Clock

è°ƒç”¨ timer_sleep() æ—¶ï¼Œçº¿ç¨‹ä¼šè¿›å…¥ BLOCKED çŠ¶æ€ï¼Œè¢«åŠ å…¥ `sleep_list` é˜Ÿåˆ—ã€‚

æ¯æ¬¡ timer_interrupt() è¢«è°ƒç”¨æ—¶ï¼Œä¼šé€’å‡ `sleep_list` ä¸­æ‰€æœ‰çº¿ç¨‹çš„ `sleep_ticks`ï¼Œå¹¶æ£€æŸ¥æ˜¯å¦æœ‰çº¿ç¨‹å·²ç»åˆ°æœŸã€‚è‹¥æœ‰ï¼Œåˆ™å°†å…¶ä» `sleep_list` ä¸­ç§»é™¤ï¼Œå¹¶å”¤é†’ï¼ˆåŠ å…¥å°±ç»ªé˜Ÿåˆ—ï¼‰ã€‚

updateï¼šæ¯æ¬¡ä¸€èˆ¬ kernel thread æœ‰æœºä¼š run æ—¶ã€‚ä¹Ÿå°±æ˜¯å…ˆæ›´æ–°æ•°æ®ï¼Œå†è°ƒåº¦ã€‚

niceï¼šçº¿ç¨‹ä»çˆ¶çº¿ç¨‹ç»§æ‰¿ niceã€‚åˆå§‹çº¿ç¨‹çš„ nice ä¸º 0ã€‚

priorityï¼šthread init æ—¶å’Œæ¯å››æ¬¡ tick æ—¶æ›´æ–°

recent_cpuï¼šç¬¬ä¸€ä¸ªçº¿ç¨‹ä¸º 0ï¼Œå…¶ä»–æ–°çº¿ç¨‹ä¸ºçˆ¶çº¿ç¨‹çš„ recent_cpuã€‚æ¯æ¬¡ timer_intr æ—¶ running threadï¼ˆé idleï¼‰çš„ recent_cpu++ã€‚æ¯ç§’ç”¨updateå‡½æ•°æ›´æ–°æ‰€æœ‰çº¿ç¨‹çš„ recent_cpu ï¼ˆtimer_ticks () % TIMER_FREQ == 0ï¼‰ã€‚å€¼å¯ä»¥ä¸ºè´Ÿã€‚

load_avgï¼šåˆå§‹ä¸ºé›¶ï¼Œæ¯ç§’æ›´æ–°ã€‚ï¼ˆtimer_ticks () % TIMER_FREQ == 0ï¼‰

TODOï¼šæŠŠ timer æ¢æˆ semaphore

TODOï¼šæ ¼å¼ï¼šcol è¶…å­—æ•°


struct donation 
{
  struct lock *lock;      
  int priority;     /* Priority of the thread that donated the priority */
  struct list_elem elem;  
};

void donate_priority(struct thread *donatee, int priority, struct lock *lock)
{
  struct donation *d;
  struct list_elem *e;
  bool found = false;

  /* Check if the lock is already in the donations list 
     (A holds lock, B waits for A, C waits for A too)
     update B's priority
     */
  for (e = list_begin (&donatee->donations); e != list_end (&donatee->donations); e = list_next (e))
  {
    d = list_entry (e, struct donation, elem);
    if (d->lock == lock)
    {
      d->priority = priority;
      found = true;
      break;
    }
  }
  if (!found)
  {
    d = (struct donation *) malloc(sizeof(struct donation));
    d->lock = lock;
    d->priority = priority;
    list_push_back(&donatee->donations, &d->elem);
  }

  update_donated_priority(donatee);
  if (donatee->waiting_lock != NULL)
    donate_priority(donatee->waiting_lock->holder, donatee->donated_priority, donatee->waiting_lock);
}

void update_donated_priority(struct thread *t)
{
  int old_priority = t->donated_priority;
  t->donated_priority = t->base_priority;

  struct donation *d;
  struct list_elem *e;
  for (e = list_begin (&t->donations); e != list_end (&t->donations); e = list_next (e))
  {
    d = list_entry (e, struct donation, elem);
    if (d->priority > t->donated_priority)
      t->donated_priority = d->priority;
  }

  if (t->donated_priority != old_priority && t->waiting_lock != NULL)
  {  
    struct thread *holder = t->waiting_lock->holder;
    update_donated_priority(holder);
  }

  if (t->status == THREAD_READY)
  {
    thread_yield();
  }
}

# Lab 2


æ–‡ä»¶ç³»ç»Ÿæ²¡æœ‰å†…éƒ¨åŒæ­¥ï¼Œå¹¶å‘çš„è®¿é—®ä¼šå¹²æ‰°å½¼æ­¤ã€‚æ–‡ä»¶å¤§å°è‡ªåˆ›å»ºæ—¶å°±å›ºå®šäº†ï¼Œä¸èƒ½æ‰©å±•ã€‚å•æ–‡ä»¶çš„æ•°æ®è¿ç»­å­˜å‚¨ã€‚æ²¡æœ‰å­ç›®å½•ã€‚æ–‡ä»¶åè‡³å¤š 14 ä¸ªå­—ç¬¦ã€‚

ç±» Unix çš„å»¶è¿Ÿåˆ é™¤æ–‡ä»¶

é˜²æ­¢å¤§é‡é”™è¯¯å¤„ç†ä»£ç å¦¨ç¢ä¸»é€»è¾‘çš„å¯è¯»æ€§ã€‚é”™è¯¯å¤„ç†æ—¶ä¿è¯é”ã€buffer ç­‰èµ„æºé‡Šæ”¾ã€‚

ä¿è¯ `exec` åœ¨å…¶ç¨‹åºç»“æŸå‰ä¸ä¼šè¿”å›ã€‚

Consider parent process P with child process C.  How do you
ensure proper synchronization and avoid race conditions when P
>calls wait(C) before C exits?  After C exits?  How do you ensure
>that all resources are freed in each case?  How about when P
>terminates without waiting, before C exits?  After C exits?  Are
>there any special cases?



```bash
docker run -it --rm --name pintos --mount type=bind,source=D:/wksp/pintos,target=/home/PKUOS/pintos pkuflyingpig/pintos bash
# æˆ–è€…
docker exec -it pintos bash

cd pintos/src/userprog/; make

cd build;

# debug åœ¨æ–°ç»ˆç«¯
pintos-gdb kernel.o  
debugpintos
# å¦‚æœè¿™ä¸€æ­¥ç½‘ç»œä¸é€šï¼Œctrl+a+x ç¬¬ä¸€ä¸ªç»ˆç«¯çš„ qemu
# ctrl+leftarrow ä¼šå¡æ­»

# æµ‹è¯•
rm tests/userprog/read-boundary.output; make tests/userprog/read-boundary.result
rm tests/filesys/base/syn-write.output; make tests/filesys/base/syn-write.result

rm tests/userprog/no-vm/multi-oom.output; make tests/userprog/no-vm/multi-oom.result

code src/userprog/build/tests/userprog/syn-read.output

make check > ~/pintos/check.txt  # run all tests
make grade > ~/pintos/grade.txt  # run all tests and grade

# ç©¶æäº”åˆä¸€ç‰ˆ
clear; make; pintos --filesys-size=2 -p ../../examples/echo -a echo -- -f -q run 'echo PKUOS'
clear; make; pintos --gdb --filesys-size=2 -p ../../examples/echo -a echo -- -f -q run 'echo PKUOS'
```

ä¿®æ”¹ `proc_info->ref_count` çš„åœ°æ–¹ï¼š

1. `process_execute`ï¼šåˆ›å»ºæ–°è¿›ç¨‹æ—¶ï¼Œçˆ¶è¿›ç¨‹è°ƒç”¨ `init_proc_info` å°† `ref_count` åˆå§‹åŒ–ä¸º 1ã€‚å¦‚æœåˆ›å»ºçº¿ç¨‹å¤±è´¥ï¼Œè°ƒç”¨ `free_proc_info_refcnt` é‡Šæ”¾ `proc_info`ã€‚
2. å­è¿›ç¨‹æ‰§è¡Œ `start_process` æ—¶ ç«‹å³å°† `ref_count` åŠ  1ã€‚
3. å­è¿›ç¨‹åŠ è½½å¤±è´¥ï¼Œè°ƒç”¨ `free_proc_info_refcnt`ï¼Œç„¶å `sema_up`ã€‚å›åˆ°çˆ¶è¿›ç¨‹ååˆè°ƒç”¨ `free_proc_info_refcnt`ï¼Œæ­¤æ—¶ `proc_info` è¢«é‡Šæ”¾.
4. çˆ¶è¿›ç¨‹è°ƒç”¨ `process_wait` æ—¶ï¼Œè°ƒç”¨ `free_proc_info_refcnt`ã€‚
5. å­è¿›ç¨‹è°ƒç”¨ `syscall_exit` æ—¶ï¼Œè°ƒç”¨ `free_proc_info_refcnt`ã€‚

`start_process` é‡Œä¿®æ”¹ `proc_info` ä¸ç”¨åŠ é”ï¼Œå› ä¸ºè¿™æ—¶çˆ¶è¿›ç¨‹å·²ç»åœ¨ç­‰å¾…äº†ã€‚

ä¸€å®šè¦è®°å¾—æ¯æ¬¡æµ‹è¯•é€šè¿‡ä¹‹å commit

`process_exit` åªä¼šè¢« `thread_exit` è°ƒç”¨ï¼Œè€Œåè€…ä¼šè¢«ï¼š

- `pintos_init`
- `kill`
- `exit`
- `start_process` if load failed
- `syscall_exit`

# Lab 3a

ä¸‹é¢æ˜¯å¯¹â€œè™šæ‹Ÿå†…å­˜ï¼ˆVMï¼‰é¡¹ç›®â€èƒŒæ™¯å’Œè¯´æ˜çš„å®Œæ•´ä¸­æ–‡ç¿»è¯‘ï¼š

---

## èƒŒæ™¯  
**æºæ–‡ä»¶**  
ä½ å°†åœ¨ `vm/` ç›®å½•ä¸‹è¿›è¡Œæœ¬é¡¹ç›®çš„å¼€å‘ã€‚

è¯¥ç›®å½•ä¸‹åªåŒ…å« Makefileï¼Œå”¯ä¸€ä¸ userprog é¡¹ç›®ä¸åŒä¹‹å¤„æ˜¯å¼€å¯äº† `-DVM` é€‰é¡¹ã€‚

ä½ æ‰€æœ‰çš„æ–°ä»£ç è¦ä¹ˆæ”¾åœ¨æ–°å»ºæ–‡ä»¶é‡Œï¼Œè¦ä¹ˆæ”¾åœ¨ä¹‹å‰é¡¹ç›®å·²ç»å¼•å…¥çš„æ–‡ä»¶é‡Œã€‚

ä»¥ä¸‹å‡ ä¸ªæ–‡ä»¶å¯èƒ½æ˜¯ä½ åœ¨æœ¬é¡¹ç›®ä¸­ç¬¬ä¸€æ¬¡æ¥è§¦åˆ°çš„ï¼š  
- `devices/block.h`  
- `devices/block.c`  

å®ƒä»¬æä¾›äº†å¯¹å—è®¾å¤‡çš„æ‰‡åŒºçº§è¯»å†™æ¥å£ï¼Œä½ å°†é€šè¿‡å®ƒæ¥è®¿é—®äº¤æ¢åˆ†åŒºï¼ˆswap partitionï¼‰ã€‚

---

## å†…å­˜æœ¯è¯­

ä¸ºäº†è®¨è®ºè™šæ‹Ÿå†…å­˜æ—¶ä¸äº§ç”Ÿæ­§ä¹‰ï¼Œéœ€è¦å…ˆä»‹ç»ä»¥ä¸‹æœ¯è¯­ï¼š

### é¡µé¢ï¼ˆPageï¼‰  
- åˆç§°è™šæ‹Ÿé¡µé¢ï¼ˆvirtual pageï¼‰ï¼Œé•¿åº¦ä¸º 4096 å­—èŠ‚ï¼ˆé¡µé¢å¤§å°ï¼‰ã€‚  
- å¿…é¡»æŒ‰é¡µé¢å¯¹é½ï¼ˆstart on a virtual address evenly divisible by the page sizeï¼‰ã€‚  
- 32 ä½è™šæ‹Ÿåœ°å€å¯åˆ†ä¸º 20 ä½é¡µå·ï¼ˆPage Numberï¼‰å’Œ 12 ä½é¡µå†…åç§»ï¼ˆOffsetï¼‰ï¼š

  ```
                 31               12 11        0
                +-------------------+-----------+
                |    é¡µ å· (VPN)    |  å ç§»   |
                +-------------------+-----------+
                        è™šæ‹Ÿåœ°å€
  ```

- æ¯ä¸ªè¿›ç¨‹éƒ½æœ‰è‡ªå·±ç‹¬ç«‹çš„ç”¨æˆ·é¡µé›†åˆï¼Œåœ°å€éƒ½åœ¨ `PHYS_BASE`ï¼ˆé€šå¸¸æ˜¯ `0xc0000000`, å³ 3 GBï¼‰ä»¥ä¸‹ã€‚  
- å†…æ ¸é¡µåˆ™æ˜¯å…¨å±€çš„ï¼Œä¸å½“å‰è¿è¡Œçš„çº¿ç¨‹æˆ–è¿›ç¨‹æ— å…³ã€‚  
- å†…æ ¸å¯ä»¥è®¿é—®ç”¨æˆ·å’Œå†…æ ¸é¡µé¢ï¼Œä½†ç”¨æˆ·è¿›ç¨‹åªèƒ½è®¿é—®è‡ªå·±ç”¨æˆ·ç©ºé—´ä¸­çš„é¡µé¢ã€‚  

 Pintos æä¾›äº†è‹¥å¹²å‡½æ•°æ¥æ“ä½œè™šæ‹Ÿåœ°å€ï¼Œå‚è§â€œè™šæ‹Ÿåœ°å€â€éƒ¨åˆ†ã€‚

### ç‰©ç†å¸§ï¼ˆFrameï¼‰  
- åˆç§°ç‰©ç†é¡µé¢ï¼ˆphysical frameï¼‰ï¼Œæ˜¯ç‰©ç†å†…å­˜ä¸­çš„ä¸€æ®µè¿ç»­ã€æŒ‰é¡µå¯¹é½çš„åŒºåŸŸï¼Œä¹Ÿæœ‰ 4096 å­—èŠ‚ã€‚  
- 32 ä½ç‰©ç†åœ°å€åŒæ ·å¯åˆ†ä¸º 20 ä½å¸§å·å’Œ 12 ä½åç§»ï¼š

  ```
                 31               12 11        0
                +-------------------+-----------+
                |   å¸§ å· (PFN)    |  å ç§»   |
                +-------------------+-----------+
                        ç‰©ç†åœ°å€
  ```

- x86 æ¶æ„æœ¬èº«ä¸å…è®¸ç›´æ¥æŒ‰ç‰©ç†åœ°å€è®¿é—®å†…å­˜ï¼ŒPintos é€šè¿‡å°†å†…æ ¸è™šæ‹Ÿå†…å­˜ä»ç¬¬ä¸€ä¸ªé¡µé¢å¼€å§‹é€ä¸€æ˜ å°„åˆ°ç‰©ç†å¸§æ¥å®ç°â€œç›´é€šâ€ï¼ˆidentity mappingï¼‰ï¼Œä»è€Œåœ¨å†…æ ¸æ¨¡å¼ä¸‹å¯ç”¨è™šæ‹Ÿåœ°å€è®¿é—®ç‰©ç†å¸§ã€‚  
- Pintos æä¾›äº†åœ¨ç‰©ç†åœ°å€å’Œå†…æ ¸è™šæ‹Ÿåœ°å€ä¹‹é—´è½¬æ¢çš„å‡½æ•°ï¼Œå‚è§â€œè™šæ‹Ÿåœ°å€â€éƒ¨åˆ†ã€‚

### é¡µè¡¨ï¼ˆPage Tableï¼‰  
- CPU ç”¨æ¥å°†è™šæ‹Ÿåœ°å€ï¼ˆé¡µå·ï¼‰ç¿»è¯‘ä¸ºç‰©ç†åœ°å€ï¼ˆå¸§å·ï¼‰çš„æ•°æ®ç»“æ„ï¼Œç”± x86 æ¶æ„è§„å®šã€‚  
- Pintos åœ¨ `pagedir.c` ä¸­å°è£…äº†é¡µè¡¨ç®¡ç†ä»£ç ï¼Œå‚è§â€œé¡µè¡¨â€ä¸€èŠ‚ã€‚  
- ä¸‹å›¾å±•ç¤ºäº†ç¿»è¯‘è¿‡ç¨‹ï¼š

  ```
                            +----------+
           .--------------->|é¡µ   è¡¨   |---------.
          /                 +----------+          |
     31   |   12 11    0                    31    V   12 11    0
    +-----------+-------+                  +------------+-------+
    | é¡µ å· (VPN) | å ç§» |                  | å¸§ å· (PFN) | å ç§» |
    +-----------+-------+                  +------------+-------+
     è™šæ‹Ÿåœ°å€      |                         ç‰©ç†åœ°å€      ^
                    \_____________________________________/
  ```

### äº¤æ¢æ§½ï¼ˆSwap Slotï¼‰  
- äº¤æ¢åˆ†åŒºï¼ˆswap partitionï¼‰ä¸Šçš„ä¸€æ®µè¿ç»­ã€æŒ‰é¡µå¯¹é½çš„ç£ç›˜ç©ºé—´ï¼Œç”¨äºå­˜æ”¾è¢«æ¢å‡ºçš„é¡µé¢ã€‚

---

## èµ„æºç®¡ç†æ¦‚è§ˆ

ä½ éœ€è¦è®¾è®¡ä»¥ä¸‹ä¸‰ç§æ•°æ®ç»“æ„ï¼š

1. **è¡¥å……é¡µè¡¨ï¼ˆSupplemental Page Tableï¼‰**  
2. **å¸§è¡¨ï¼ˆFrame Tableï¼‰**  
3. **äº¤æ¢è¡¨ï¼ˆSwap Tableï¼‰**

> **æç¤º**  
> ä½ å¯ä»¥æŠŠç›¸å…³ç»“æ„åˆå¹¶åœ¨ä¸€èµ·ã€‚æ¯ä¸ªç»“æ„ä¸­çš„æ¡ç›®è¦åŒ…å«å“ªäº›å­—æ®µï¼Ÿæ¯ç§ç»“æ„æ˜¯â€œå…¨å±€â€ï¼ˆç³»ç»Ÿçº§ï¼‰è¿˜æ˜¯â€œå±€éƒ¨â€ï¼ˆæ¯ä¸ªè¿›ç¨‹ä¸€ä»½ï¼‰ï¼Ÿä½ ä¹Ÿè¦è€ƒè™‘å°†å®ƒä»¬æ”¾åœ¨éåˆ†é¡µå†…å­˜ä¸­ï¼Œè¿™æ ·æŒ‡é’ˆå°±ä¸€ç›´æœ‰æ•ˆã€‚

å¯é€‰çš„æ•°æ®ç»“æ„æœ‰ï¼šæ•°ç»„ã€é“¾è¡¨ã€ä½å›¾ï¼ˆbitmapï¼‰ã€å“ˆå¸Œè¡¨ï¼ˆhash tableï¼‰ç­‰ã€‚  
- æ•°ç»„ç›´è§‚ä½†å¯èƒ½æµªè´¹ç©ºé—´ï¼›  
- é“¾è¡¨æ–¹ä¾¿å¢åˆ ä½†æŸ¥æ‰¾æ…¢ï¼›  
- ä½å›¾ï¼ˆPintos å·²æä¾›ï¼‰éå¸¸é€‚åˆè®°å½•â€œèµ„æº n æ˜¯å¦å·²ç”¨â€ï¼›  
- å“ˆå¸Œè¡¨ï¼ˆPintos å·²æä¾›ï¼‰é€‚åˆå¤§è§„æ¨¡åŠ¨æ€çš„å¢åˆ æŸ¥ã€‚

---

## ç®¡ç†è¡¥å……é¡µè¡¨

è¡¥å……é¡µè¡¨ä¿å­˜äº†é¡µè¡¨æœ¬èº«è¡¨ç¤ºä¸äº†çš„ä¿¡æ¯ã€‚  
- **é¡µé¢é”™è¯¯ï¼ˆPage Faultï¼‰æ—¶**ï¼Œå†…æ ¸æŸ¥æ­¤è¡¨è·å–è¯¥è™šæ‹Ÿé¡µçš„æ•°æ®æ¥æºï¼šæ–‡ä»¶ç³»ç»Ÿï¼Ÿäº¤æ¢ï¼Ÿè¿˜æ˜¯â€œå…¨é›¶â€é¡µé¢ï¼Ÿ  
- **è¿›ç¨‹ç»ˆæ­¢æ—¶**ï¼Œå†…æ ¸æŸ¥æ­¤è¡¨é‡Šæ”¾å¯¹åº”èµ„æºã€‚

ä½ å¯ä»¥æŒ‰â€œèŠ‚ï¼ˆsegmentï¼‰â€æˆ–â€œé¡µï¼ˆpageï¼‰â€æ¥ç»„ç»‡è¯¥è¡¨ã€‚  
é«˜çº§æ–¹æ¡ˆï¼šæŠŠè¡¥å……ä¿¡æ¯ç›´æ¥æŒ‚åˆ°ç¡¬ä»¶é¡µè¡¨æ¡ç›®ä¸­ï¼ˆæ”¹ `pagedir.c`ï¼‰ï¼Œä½†è¾ƒå¤æ‚ï¼Œä»…å»ºè®®ç»™è¿›é˜¶åŒå­¦ã€‚  

**Page Fault å¤„ç†**ï¼ˆä¿®æ”¹ `userprog/exception.c` ä¸­çš„ `page_fault()`ï¼‰çš„å¤§è‡´æµç¨‹ï¼š  
1. åœ¨è¡¥å……é¡µè¡¨ä¸­æŸ¥æ‰¾å‡ºé”™çš„è™šæ‹Ÿé¡µï¼›  
   - è·å–æ•°æ®æ¥æºï¼šæ–‡ä»¶ç³»ç»Ÿï¼Ÿäº¤æ¢ï¼Ÿè¿˜æ˜¯â€œå…¨é›¶â€é¡µé¢ï¼Ÿ
   - è‹¥å®ç°äº†å…±äº«ï¼Œåˆ™é¡µçš„æ•°æ®å¯èƒ½å·²ç»åœ¨ç‰©ç†é¡µä¸­ï¼Œåªæ˜¯é¡µè¡¨ä¸­æ²¡æœ‰
2. å¦‚æœè®¿é—®æ— æ•ˆï¼ˆä¾‹å¦‚è®¿é—®å†…æ ¸åœ°å€æˆ–å†™å…¥åªè¯»é¡µï¼‰ï¼Œç»ˆæ­¢è¿›ç¨‹ï¼›  
3. ç”³è¯·ï¼ˆæˆ–å¤ç”¨å…±äº«æ—¶å·²æœ‰çš„ï¼‰ç‰©ç†å¸§
4. è‹¥æ•°æ®åœ¨æ–‡ä»¶æˆ–äº¤æ¢åˆ†åŒºï¼Œåˆ™è¯»å…¥ï¼›å¦åˆ™æ¸…é›¶ï¼›  
5. æ›´æ–°ç¡¬ä»¶é¡µè¡¨æ¡ç›®ï¼Œä½¿è¯¥è™šæ‹Ÿé¡µæ˜ å°„åˆ°ç‰©ç†å¸§ã€‚

---

## ç®¡ç†å¸§è¡¨

å¸§è¡¨è®°å½•æ‰€æœ‰å·²è¢«ç”¨æˆ·é¡µé¢å ç”¨çš„ç‰©ç†å¸§ã€‚  
æ¯æ¡ç›®åŒ…å«ï¼šè¯¥å¸§å½“å‰å¯¹åº”çš„è™šæ‹Ÿé¡µæŒ‡é’ˆï¼Œä»¥åŠç”¨äºé¡µé¢ç½®æ¢ç®—æ³•çš„è¾…åŠ©ä¿¡æ¯ã€‚

- ç”¨æˆ·é¡µçš„ç‰©ç†å¸§éœ€é€šè¿‡ `palloc_get_page(PAL_USER)` ç”³è¯·ï¼Œé¿å…å ç”¨å†…æ ¸é¡µæ± ï¼ˆå¦åˆ™æŸäº›æµ‹è¯•ä¼šæŒ‚ï¼‰ã€‚  
- è‹¥æ— ç©ºé—²å¸§ï¼Œåˆ™éœ€ **é©±é€ï¼ˆevictï¼‰** æŸé¡µï¼š  
  1. ç”¨ç½®æ¢ç®—æ³•é€‰å‡ºä¸€å¸§ï¼ˆå¯ç”¨â€œè®¿é—®ä½ï¼ˆaccessedï¼‰â€å’Œâ€œè„ä½ï¼ˆdirtyï¼‰â€ï¼‰ï¼›  
  2. ä»ç›¸åº”é¡µè¡¨ä¸­ç§»é™¤æ˜ å°„ï¼›ï¼ˆé™¤éå®ç°äº†å…±äº«ï¼Œå¦åˆ™ä¸€ä¸ªç‰©ç†é¡µåªä¼šå¯¹åº”ä¸€ä¸ªè™šæ‹Ÿé¡µï¼‰
  3. å¦‚éœ€ï¼Œå†™å›æ–‡ä»¶æˆ–äº¤æ¢ï¼›  
  4. è¯¥å¸§å³å¯é‡ç”¨ã€‚

> å¦‚æœæ‰¾ä¸åˆ°å¯é©±é€ä¸”ä¸å†™äº¤æ¢åŒºå°±ä¸èƒ½é‡Šæ”¾çš„å¸§ï¼ˆä¸”äº¤æ¢ä¹Ÿæ»¡äº†ï¼‰ï¼Œå†…æ ¸ panicã€‚

### è®¿é—®ä½ä¸è„ä½  
- CPU åœ¨é¡µé¢è¢«è¯»/å†™æ—¶è‡ªåŠ¨ç½®â€œè®¿é—®ä½â€ï¼›åœ¨å†™æ—¶ç½®â€œè„ä½â€ã€‚  
- OS å¯åœ¨é©±é€ç®—æ³•ä¸­æ‰‹åŠ¨æ¸…é›¶è¿™äº›ä½ï¼ˆCPU æ°¸è¿œä¸ä¼šæ¸…é›¶è¿™äº›ä½ï¼‰ã€‚  
- æ³¨æ„åˆ«åï¼ˆaliasï¼‰é—®é¢˜ï¼šåŒä¸€å¸§è‹¥è¢«å¤šä¸ªè™šæ‹Ÿé¡µ â€œæ˜ å°„â€ï¼Œåªæœ‰å®é™…è®¿é—®çš„é‚£ä¸ªé¡µè¡¨æ¡ç›®çš„ä½ä¼šæ›´æ–°ã€‚Pintos é»˜è®¤è¿˜ä¸ºå†…æ ¸è™šæ‹Ÿåœ°å€åšäº†åˆ«åï¼Œä½ è¦åœ¨é©±é€å’Œæ£€æµ‹æ—¶ä¸€å¹¶è€ƒè™‘ã€‚
- æ£€æŸ¥å†…æ ¸è™šæ‹Ÿåœ°å€å’Œç”¨æˆ·è™šæ‹Ÿåœ°å€çš„è®¿é—®ä½ä¸è„ä½
- æˆ–è€…ç¡®ä¿å†…æ ¸åªä½¿ç”¨ç”¨æˆ·è™šæ‹Ÿåœ°å€è®¿é—®ç”¨æˆ·æ•°æ®
- å…¶ä»–åˆ«ååªä¼šåœ¨å®ç°å…±äº«çš„æƒ…å†µä¸‹ï¼ˆæˆ– bugï¼‰å‡ºç°

---

## ç®¡ç†äº¤æ¢è¡¨

äº¤æ¢è¡¨è®°å½•äº¤æ¢æ§½çš„â€œå·²ç”¨/ç©ºé—²â€æƒ…å†µã€‚  
å®ƒåº”æ”¯æŒï¼š  
- ç”³è¯·ä¸€ä¸ªç©ºé—²æ§½ï¼Œç”¨æ¥å†™å‡ºï¼ˆevictï¼‰æŸå¸§ï¼›  
- é‡Šæ”¾æŸæ§½ï¼Œå½“å…¶é¡µé¢è¢«è¯»å›æˆ–è¿›ç¨‹ç»ˆæ­¢ï¼›

å®ç°ç»†èŠ‚ï¼š  
- ä½¿ç”¨ `BLOCK_SWAP` è®¾å¤‡ï¼ˆè°ƒç”¨ `block_get_role()` è·å–å¯¹åº”çš„ `struct block`ï¼‰ã€‚  
- åœ¨ `vm/build` ç›®å½•ä¸‹ï¼Œç”¨ `pintos-mkdisk swap.dsk --swap-size=n` åˆ›å»ºä¸€ä¸ªå¤§å°ä¸º n MB çš„äº¤æ¢ç›˜ã€‚  
- æˆ–è€…åœ¨è¿è¡Œæ—¶ç”¨ `--swap-size=n` ä¸´æ—¶æŒ‡å®šäº¤æ¢ç›˜å¤§å°ã€‚  
- äº¤æ¢æ§½æŒ‰éœ€åˆ†é…ï¼ˆlazyï¼‰
  - Reading data pages from the executable and writing them to swap immediately at process startup is not lazy.
  - ä¸èƒ½ç”¨äº¤æ¢æ§½å­˜ç‰¹å®šçš„é¡µ
  - å½“äº¤æ¢æ§½çš„å†…å®¹è¢«è¯»å›ç‰©ç†é¡µæ—¶ï¼Œé‡Šæ”¾äº¤æ¢æ§½

## åŠ è½½

åŠ è½½å¯æ‰§è¡Œæ–‡ä»¶æ—¶ï¼Œåªå»ºç«‹ç”¨æˆ·é¡µåˆ°æ–‡ä»¶å†…å®¹çš„æ˜ å°„å…³ç³»ï¼Œä¸è¯»å…¥æ•°æ®ã€‚

å½“ç¬¬ä¸€æ¬¡è®¿é—®é¡µæ—¶ï¼Œè§¦å‘ page faultï¼Œåœ¨é‚£é‡ŒåŠ è½½ï¼ˆlazily loadï¼‰ï¼š  
- idea 1: å°†ç£ç›˜åœ°å€å­˜åœ¨ PTEï¼Œå°±åƒ ICS é‡Œ
- idea 2: å…¶ä»–æ•°æ®ç»“æ„ï¼ˆè¡¥å……é¡µè¡¨ï¼Ÿï¼‰å­˜åœ¨ threadï¼Ÿ

æ€ä¹ˆåŠ è½½ï¼š  
- æŠŠé¡µè¯»å…¥å†…å­˜
  - æ›¿æ¢ç­–ç•¥
- æ›´æ–° PTEï¼Œç”¨å·²æœ‰çš„æ¥å£ `threads/pte.h`, `userprog/pagedir.h(c)`

åœ¨ Lab 3ï¼Œåªéœ€è¦ç®¡ç† user pool é‡Œçš„å¸§ï¼š  
- ç¡®ä¿åœ¨ä¹‹å‰ä»æœªä½¿ç”¨è¿‡ user pool çš„å¸§
- kernel pool ä¸ä¼šæœ‰è¿‡å¤§å‹åŠ›

hash è¡¨ï¼šç”¨æˆ·é¡µåˆ° swap ç©ºé—´æˆ–æ–‡ä»¶å†…å®¹çš„æ˜ å°„ï¼Œpage -> frame çš„æ˜ å°„ 
- ç”¨ hash è¡¨å­˜ Keyï¼ŒæŠŠ key å’Œ value æ”¾åœ¨ä¸€ä¸ªç»“æ„ä½“é‡Œ

process exit é‡Šæ”¾èµ„æº

ç£ç›˜æ‰‡åŒº 512 å­—èŠ‚ï¼Œé¡µ 4096 å­—èŠ‚

å¸§è¡¨ï¼š  
- å…¨å±€ï¼Œæ¯ä¸ªæ¡ç›®å¯¹åº”ä¸€ä¸ªç‰©ç†å¸§ï¼Œå­˜ä¸€ä¸ªç”¨æˆ·é¡µï¼ˆå†…æ ¸é¡µï¼‰ã€ç”¨æˆ·çº¿ç¨‹æŒ‡é’ˆã€‚
- æ•´ä¸ªå¸§è¡¨è¢«ä¸€ä¸ªå…¨å±€ lock ä¿æŠ¤
- ç©ºé—²å¸§é€šè¿‡ `palloc_get_page(PAL_USER)` è·å–ï¼Œè‹¥æ²¡æœ‰ç©ºé—²å¸§ï¼Œåˆ™é©±é€ä¸€ä¸ªå¸§ï¼ˆclock algorithmï¼‰
- é©±é€ï¼š  
  - å¦‚æœè„ï¼Œå†™å› swap
  - æ¸…é™¤ PTE
  - é‡ç”¨å…¶å¸§
  - å¦‚æœ swap æ»¡äº†ï¼Œpanic

æ¯ä¸ªçº¿ç¨‹éƒ½æ‹¥æœ‰ä¸€ä¸ª pagedirï¼Œåˆ‡æ¢çº¿ç¨‹æ—¶åˆ‡æ¢ pagedirã€‚å†…æ ¸çº¿ç¨‹çš„ pagedir ä¸º NULLï¼ˆå®é™…ä¸Šæ˜¯ init_page_dirï¼‰ã€‚


```bash
docker run -it --rm --name pintos --mount type=bind,source=D:/wksp/pintos,target=/home/PKUOS/pintos pkuflyingpig/pintos bash
# æˆ–è€…
docker exec -it pintos bash

pintos --filesys-size=2 -p build/tests/vm/page-parallel -a pp -- -f -q run 'pp'

# at build/
pintos --gdb -v -k -T 60 --qemu  --filesys-size=2 -p tests/vm/page-parallel -a page-parallel -p tests/vm/child-linear -a child-linear --swap-size=4 -- -q  -f run page-parallel < /dev/null

cd pintos/src/vm/; make grade > ~/pintos/grade.txt  # run all tests and grade

cd build;

# debug åœ¨æ–°ç»ˆç«¯
pintos-gdb kernel.o  
debugpintos
# å¦‚æœè¿™ä¸€æ­¥ç½‘ç»œä¸é€šï¼Œctrl+a+x ç¬¬ä¸€ä¸ªç»ˆç«¯çš„ qemu
# ctrl+leftarrow ä¼šå¡æ­»

# æµ‹è¯•
rm build/tests/userprog/open-null.output; make build/tests/userprog/open-null.result  # userprog

rm build/tests/filesys/base/syn-write.output; make build/tests/filesys/base/syn-write.result  # filesys

rm build/tests/vm/page-linear.output; make build/tests/vm/page-linear.result            # vm
rm build/tests/vm/page-parallel.output; make build/tests/vm/page-parallel.result            # vm

rm build/tests/vm/mmap-read.output; make build/tests/vm/mmap-read.result            # vm

code src/userprog/build/tests/userprog/syn-read.output

make clean; 
make grade > ~/pintos/grade.txt  # run all tests and grade
```

ç±»å‹ï¼šæ¸…é™¤ void *ï¼Œä¸º kpage è®¾ç½®ç±»å‹ã€‚

å¦‚æœæ˜¯ä» swap è¯»å‡ºæ¥çš„ï¼Œéœ€è¦ç½®è„ä½ï¼ï¼ï¼

spe ä¹Ÿæ˜¯å…±äº«çš„ï¼Œéœ€è¦é”ä¿æŠ¤ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼ï¼

å§‹ç»ˆä½¿ç”¨ç”¨æˆ·è™šæ‹Ÿåœ°å€æ¥è®¿é—®æ•°æ®ï¼Œåªåœ¨ page fault æ—¶é€šè¿‡å†…æ ¸åœ°å€è®¿é—®ï¼ˆè¿™ä¸ä¼šé€ æˆ accessed å’Œ dirty ä½è¢«è®¾ç½®ï¼‰ã€‚

palloc ä¹Ÿéœ€è¦é”ï¼

å³ä¾¿åªæ˜¯è¯» SPEï¼ˆsupplemental page entryï¼‰é‡Œçš„æ•°æ®ï¼Œä¹Ÿå¿…é¡»å…ˆæ‹¿ä¸Šé‚£æŠŠ SPE é”ï¼Œå¦åˆ™å°±æœ‰å¯èƒ½å’Œåˆ«çš„çº¿ç¨‹åœ¨åšé©±é€/åé©±é€ã€åˆ é™¤/æ’å…¥ç­‰æ“ä½œæ—¶å‘ç”Ÿç«æ€ï¼Œçœ‹è§åŠæ›´æ–°ç”šè‡³é‡æŒ‡é’ˆã€‚

ä¸ºä»€ä¹ˆè¯»ä¹Ÿè¦é”ï¼Ÿ

é©±é€çº¿ç¨‹åœ¨åš evict æ—¶ï¼Œä¼šå…ˆæ‹¿ SPE é”ã€ç§»é™¤æ˜ å°„ã€å†é‡Šæ”¾ç‰©ç†å¸§ã€‚å¦‚æœä½ ä¸é”ï¼Œå°±æœ‰å¯èƒ½åœ¨å®ƒåˆšç§»é™¤æ˜ å°„ä¹‹åã€è¿˜æ²¡ç»“æŸæ•´ä¸ªæ¸…ç†æµç¨‹ä¹‹å‰è¯»åˆ°ä¸€ä¸ªâ€œç©ºâ€æˆ–è¢«å›æ”¶çš„æ¡ç›®ã€‚

åå‘çš„â€œun-evictâ€ï¼ˆæŠŠé¡µè°ƒå›ï¼‰ä¹Ÿéœ€è¦ SPE é”ã€‚è¯»æ“ä½œè‹¥ä¸é”ï¼Œå°±å¯èƒ½åœ¨è¿™ä¸­é—´æŠ¢å…ˆè¯»åˆ°ä¸å®Œæ•´æˆ–é”™è¯¯çš„çŠ¶æ€ã€‚

å”¯ä¸€ä¸éœ€è¦æ‹¿ SPE é”çš„æƒ…å†µï¼Œæ˜¯ä½ èƒ½ç¡®å®šè¯¥ SPE è‡ªåˆ›å»ºä»¥æ¥æ‰€æœ‰æ¶‰åŠå®ƒçš„å­—æ®µéƒ½åªè¯»ä¸”ä»ä¸ä¿®æ”¹ï¼ˆæ¯”å¦‚æŸäº›å¸¸é‡å…ƒä¿¡æ¯ï¼‰ï¼Œå¹¶ä¸”ä½ å·²ç»åœ¨æ›´é«˜å±‚ï¼ˆæ¯”å¦‚å…¨è¡¨é”æˆ–åˆå§‹åŒ–é˜¶æ®µï¼‰ä¿è¯äº†å®ƒçš„æ°¸è¿œâ€œåªè¯»â€å±æ€§ã€‚ä½†åœ¨æˆ‘ä»¬çš„ VM å®ç°é‡Œï¼ŒSPE é‡Œé€šå¸¸åŒ…å«è¯¸å¦‚çŠ¶æ€ä½ã€swap ä½ç½®ã€æ–‡ä»¶åç§»ç­‰ä¼šè¢«é©±é€ã€åŠ è½½ä»£ç ä¿®æ”¹çš„å­—æ®µï¼Œæ‰€ä»¥åªè¯»ä¹Ÿè¦é”ã€‚

åªè¦ä¸€ä¸ªå¸§è¢«é€‰å®šï¼Œå®ƒå°±è¢« pinnedï¼ˆclock

å½“ P è·å¾—åŸæ¥å±äº Q çš„é¡µï¼Œé¦–å…ˆ pinï¼Œç„¶åè·å–æ­¤é¡µç›¸å…³çš„ spe é”ï¼Œä» Q é¡µè¡¨ç§»é™¤ã€‚Q åœ¨é‡æ–° swap in å®ƒä¹‹å‰ä¹Ÿè¦è·å¾— spe é”ã€‚

ç¡®ä¿é”é¡ºåºã€‚å…ˆ filesysï¼Œå†å¸§é”ï¼Œå† spt é”ï¼Œå† spe é”ã€‚

æ¯ä¸ªè¿›ç¨‹æœ‰ä¸€ä¸ª spt é”ï¼Œåœ¨ page fault æŸ¥æ‰¾æˆ– spt æ’å…¥åˆ é™¤æ—¶ä½¿ç”¨ã€‚æŸ¥æ‰¾æ—¶å¿…é¡»å…ˆè·å– spt é”ï¼Œç„¶åè·å– spe é”ã€‚è¿™æ ·å¯ä»¥é¿å…æ­»é”çš„å¯èƒ½æ€§ã€‚è‹¥ä¸€ä¸ªçº¿ç¨‹æŒæœ‰é¡µé¡¹é”å¹¶å°è¯•æŸ¥æ‰¾ï¼Œè€Œå¦ä¸€ä¸ªçº¿ç¨‹åä¹‹ï¼ˆå³æŒæœ‰å“ˆå¸Œè¡¨é”åŒæ—¶å°è¯•è·å–é¡µé¡¹é”ï¼‰ï¼Œå¯èƒ½ä¼šå‡ºç°æ­»é”ã€‚ä½†æˆ‘ä»¬é€šè¿‡åœ¨å¸§è¡¨é¡¹ä¸­æ·»åŠ ä¸€ä¸ªæŒ‡å‘å…¶å¯¹åº”é¡µè¡¨é¡¹çš„æŒ‡é’ˆæ¥æ¶ˆé™¤äº†è¿™ç§ä»£ç è·¯å¾„ã€‚

æˆ‘ä»¬ä¸ºè¡¥å……é¡µè¡¨é¡¹è®¾ç½®äº†é”ï¼Œåªæœ‰åœ¨è·å–è¯¥é”åï¼Œæ‰èƒ½é©±é€æˆ–å–æ¶ˆé©±é€é¡µé¢ã€‚

æˆ‘ä»¬é€šè¿‡å…ˆä» Q çš„é¡µè¡¨ä¸­ç§»é™¤è¯¥æ˜ å°„ï¼Œç„¶åå†å¼€å§‹é©±é€è¿‡ç¨‹ï¼Œä»è€Œé˜²æ­¢ Q åœ¨é©±é€ä¸­æœŸå†™å…¥è¯¥é¡µï¼ˆå¦åˆ™ä¼šç«‹åˆ»è§¦å‘é¡µé”™è¯¯ï¼‰ã€‚

å…·ä½“æ¥è¯´ï¼Œåœ¨æˆ‘ä»¬çš„é¡µé”™è¯¯å¤„ç†å‡½æ•°ä¸­ï¼Œæˆ‘ä»¬é¦–å…ˆå°è¯•è°ƒå…¥é¡µé¢ã€‚å¦‚æœå¤±è´¥ï¼ˆä¾‹å¦‚é¡µé¢æ— æ•ˆï¼‰ï¼Œæˆ‘ä»¬ä¼šå°è¯•æ‰©å±•æ ˆï¼ˆstackï¼‰ã€‚éšåï¼Œå¦‚æœå¤„ç†å™¨å½“å‰å¤„äºç”¨æˆ·ä¸Šä¸‹æ–‡ä¸­ï¼Œæˆ‘ä»¬ä¼šç»ˆæ­¢è¯¥è¿›ç¨‹ï¼›ä½†å¦‚æœå¤„äºå†…æ ¸ä¸Šä¸‹æ–‡ï¼Œæˆ‘ä»¬ä¼šæ£€æŸ¥ç‰¹æ®Šå˜é‡æ¥å‘å†…æ ¸ä¼ é€’é”™è¯¯ä¿¡å·ã€‚

[x] page-linear
[] page-parallel
[x] page-shuffle
[] page-merge-seq
[] page-merge-par
[x] pt-bad-addr
[x] pt-bad-read
[x] pt-write-code
[x] pt-write-code2
[x] pt-grow-bad

å…¨è¡¨é”â€”â€”åªåœ¨ä¿®æ”¹è¡¨ç»“æ„ï¼ˆæ’å…¥/åˆ é™¤/éå†ï¼‰æ—¶ç”¨ï¼›

è¡¨é¡¹é”â€”â€”å¯¹å•ä¸ª SPE çš„çŠ¶æ€ä¿®æ”¹ï¼ˆé©±é€ã€åé©±é€ã€è¯»æ ‡å¿—ç­‰ï¼‰æ—¶ç”¨ã€‚


1. å¸§å¤ç”¨ï¼é©±é€ï¼ˆevictionï¼‰é€»è¾‘é”™è¯¯
ç°è±¡
åœ¨é«˜å¹¶å‘ä¸‹ï¼Œä¸€ä¸ªå­è¿›ç¨‹åœ¨è§¦å‘é¡µé”™è¯¯ï¼Œæ­£åœ¨æŠŠå¸§å†™å‡º swapï¼æ–‡ä»¶ï¼›æ­¤æ—¶å¦ä¸€å­è¿›ç¨‹çš„è®¿é—®æŠŠå®ƒåˆæ‹¿èµ°åš evictï¼åŠ è½½ï¼Œé€ æˆæ•°æ®å†™æ··ä¹±æˆ–è®¿é—®æœªæ˜ å°„é¡µã€‚

å¯èƒ½åŸå› 

pin/unpin é€»è¾‘æœ‰é—æ¼ï¼šåœ¨åŠ è½½æˆ–å†™å›è¿‡ç¨‹ä¸­ï¼Œæ²¡æœ‰æŠŠå¯¹åº” frame æ ‡è®°ä¸º pinnedï¼Œå¯¼è‡´ clock ç®—æ³•é€‰ä¸­äº†æ­£åœ¨ä½¿ç”¨çš„å¸§ã€‚

supplemental page entryï¼ˆSPEï¼‰é”ä¸å¸§è¡¨é”çš„åŠ è§£é”é¡ºåºä¸å¯¹ï¼Œå¯¼è‡´é©±é€å’ŒåŠ è½½åŒæ—¶ä½œç”¨åˆ°åŒä¸€ä¸ªç‰©ç†å¸§ã€‚

æ’æŸ¥

åœ¨ frame_alloc_and_lock()ã€frame_free()ã€evict_frame() ç­‰å‡½æ•°é‡Œï¼ŒåŠ æ—¥å¿—ï¼šä»€ä¹ˆæ—¶å€™ pinã€ä»€ä¹ˆæ—¶å€™ unpinï¼›å¹¶æ‰“å°å½“å‰å¸§è¢«å“ªä¸ª SPE æŒæœ‰ã€‚

ç”¨å¤šè¿›ç¨‹å¹¶å‘è®¿é—®åŒä¸€å¤§æ•°ç»„ï¼Œåˆ¶é€ å‹åŠ›ï¼Œçœ‹æ˜¯å¦èƒ½é‡ç°â€œæ­£åœ¨è¯»æ–‡ä»¶çš„å¸§è¢«ç«‹åˆ»è¸¢èµ°â€æƒ…å½¢ã€‚

æ”¹è¿›

åœ¨æ‰€æœ‰æ–‡ä»¶è¯»å…¥ï¼ˆloadï¼‰å’Œå†™å‡ºï¼ˆevictï¼‰æ•´ä¸ªè¿‡ç¨‹å‰åï¼Œæ˜¾å¼ pin/unpinï¼š

c
å¤åˆ¶
ç¼–è¾‘
  frame_pin (f);
  do_io_read_or_write (...);
  frame_unpin (f);
é©±é€å‰å…ˆæ‹¿ SPE é”ï¼Œå† pinï¼Œå†å†™å›ï¼Œå†è§£é”ã€unpinã€‚åŠ è½½åŒç†ã€‚

4. åŒæ­¥ï¼é”é—æ¼
ç°è±¡
å¶å‘æ€§çš„å†…å­˜è®¿é—®é”™è¯¯ï¼ˆæ¯”å¦‚çªå‘é¡µé”™è¯¯ï¼Œæˆ–è€…ç›´æ¥è®¿é—®åˆ°äº†éæ³•åœ°å€ï¼‰ï¼Œå¾€å¾€æ˜¯å¹¶å‘æ—¶ hash è¡¨ã€å¸§è¡¨æˆ– SPE è®¿é—®å‡ºé”™ã€‚

å¯èƒ½åŸå› 

åœ¨å¯¹ SPE åªè¯»æ—¶ä¹Ÿå¿˜äº†æ‹¿ SPE é”ï¼Œå¯¼è‡´è¯»å–åˆ°ä¸ç¨³å®šçŠ¶æ€ã€‚

åœ¨è°ƒåº¦åˆ‡æ¢ã€æ—¶é’Ÿä¸­æ–­ã€TLB åˆ·æ–°ç­‰è·¯å¾„ä¸Šï¼Œæ²¡æœ‰æ­£ç¡®ä¿æŠ¤é¡µç›®å½•æˆ– TLBã€‚

æ’æŸ¥

å…¨æ–‡æœç´¢æ‰€æœ‰å¯¹ supplemental_page_tableã€frame_tableã€pagedir çš„è¯»å†™ä½ç½®ï¼Œç¡®è®¤æ¯ä¸€å¤„éƒ½åœ¨ç›¸åº”é”ä¿æŠ¤ä¸‹ã€‚

åœ¨é«˜å¹¶å‘åœºæ™¯ä¸‹ï¼ŒæŠŠæ‰€æœ‰é”çš„ acquire/release æ‰“æ—¥å¿—ï¼Œæ‰¾ä¸€ä¸‹æœ‰æ²¡æœ‰â€œacquire ä½†æ²¡ releaseâ€æˆ–â€œuse å‰æ²¡ acquireâ€ã€‚

æ”¹è¿›

ä¿è¯å¯¹SPE ä»»ä½•åŸŸçš„è¯»ï¼Œéƒ½è¦å…ˆ lock_acquire (&spe->lock)ï¼Œè¯»å®Œå† lock_releaseã€‚å³ä¾¿åªæ˜¯è¯» is_swappedã€swap_slotã€writable ç­‰æ ‡å¿—ä½ã€‚

åœ¨ process_exit()ã€page_exit()ã€page_clear() ç­‰æ¸…ç†è·¯å¾„ä¸Šï¼Œä¹Ÿè¦å…ˆé”ååš hash_delete()ã€frame_free()ã€‚

æ€»ç»“
å…ˆéªŒè¯ï¼šæ¯ä¸ªå­è¿›ç¨‹æ˜¯å¦çœŸçš„æ‹¥æœ‰ç‹¬ç«‹çš„é¡µç›®å½•+è¡¥å……é¡µè¡¨ã€‚

æ£€æŸ¥åŠ è½½ï¼šBSS æ¸…é›¶ã€æ‡’åŠ è½½é€»è¾‘ã€‚

å¼ºåŒ– pin/unpinï¼šä»»ä½• I/O è¯»å†™éƒ½è¦ pinï¼Œé¿å…æ­£åœ¨æ“ä½œçš„å¸§è¢«é©±é€ã€‚

é”çš„è¦†ç›–é¢ï¼šåªè¦è®¿é—® SPE æˆ–å¸§è¡¨ï¼Œè®°å¾—å…ˆæ‹¿é”ã€‚

æŒ‰ä¸Šé¢æ€è·¯é€æ­¥æ‰“æ—¥å¿—æ’æŸ¥ï¼ŒåŸºæœ¬èƒ½å®šä½æ˜¯â€œæ®µè£…è½½â€è¿˜æ˜¯â€œå¹¶å‘é©±é€â€è¿˜æ˜¯â€œé¡µè¡¨éš”ç¦»â€å“ªä¸ªç¯èŠ‚å‡ºé—®é¢˜ã€‚è°ƒé€šåï¼Œå†æ ¹æ®æ€§èƒ½å’Œå¹¶å‘éœ€æ±‚ï¼Œå†³å®šæ˜¯å¦å†åšé”ä¼˜åŒ–ã€‚ç¥è°ƒè¯•é¡ºåˆ©ï¼


load çš„æ—¶å€™è·å–äº†æ–‡ä»¶ç³»ç»Ÿé”ï¼Œè¿™æ—¶å€™å¦‚æœåœ¨ setup stack ä¸­ä¸Šä¸‹æ–‡åˆ‡æ¢å‘ç”Ÿ page faultï¼Œä¼šé‡å¤è·å–æ–‡ä»¶ç³»ç»Ÿé”ã€‚è§£å†³æ–¹æ³•ï¼šåœ¨ setup stack ä¹‹å‰è§£é”ã€‚

æ£€æŸ¥ upageï¼Œå°¤å…¶æ˜¯ set pinned

FAIL
Kernel panic in run: PANIC at ../../threads/synch.c:197 in lock_acquire(): assertion `!lock_held_by_current_thread (lock)' failed.
Call stack: 0xc0029abd 0xc0022f43 0xc0030bb4 0xc002dc15 0xc0021df5 0xc0022015 0xc002d405 0xc002d7d2 0xc0030653 0xc003079d 0xc0030c12 0xc002dc15 0xc0021df5 0xc0022015 0x80482b1 0x80480dc 0x8048916
Translation of call stack:
In kernel.o:
0xc0029abd: debug_panic (.../../lib/kernel/debug.c:38)
0xc0022f43: lock_acquire (...../../threads/synch.c:199)
0xc0030bb4: load_page_from_spt (...build/../../vm/page.c:120)
0xc002dc15: page_fault (.../userprog/exception.c:178)
0xc0021df5: intr_handler (..../threads/interrupt.c:367)
0xc0022015: intr_entry (threads/intr-stubs.S:38)
0xc002d405: lookup_page (.../../userprog/pagedir.c:69)
0xc002d7d2: pagedir_is_accessed (...../userprog/pagedir.c:195)
0xc0030653: pick_victim_frame (...build/../../vm/frame.c:74)
0xc003079d: frame_alloc (...uild/../../vm/frame.c:121)
0xc0030c12: load_page_from_spt (...build/../../vm/page.c:140)
0xc002dc15: page_fault (.../userprog/exception.c:178)
0xc0021df5: intr_handler (..../threads/interrupt.c:367)
0xc0022015: intr_entry (threads/intr-stubs.S:38)
In tests/vm/page-parallel:
0x080482b1: shuffle (...ib.c:74 (discriminator 3))
0x080480dc: test_main (...sts/vm/page-parallel.c:20)
0x08048916: random_ulong (...ild/../../lib/random.c:81)
Translations of user virtual addresses above are based on a guess at
the binary to use.  If this guess is incorrect, then those
translations will be misleading.

é©±é€æŸ¥ accessed bitï¼ŒæŸ¥ pd çš„æ—¶å€™ç¼ºé¡µï¼Œå¯¼è‡´é”é‡å¤è·å–ã€‚

frame lock åœ¨å¤–å±‚ç®¡ç†ã€‚å»æ‰è¡¨é¡¹é”

å¯¹ pagedir çš„è®¿é—®ï¼šå”¯ä¸€çš„å¯èƒ½å†²çªå‘ç”Ÿåœ¨ï¼Œä¸€ä¸ªçº¿ç¨‹åœ¨é©±é€ï¼ˆæ¶‰åŠè¯»è„ä½ã€æ¸…ç©ºé¡µè¡¨é¡¹ï¼‰ï¼Œå¦ä¸€ä¸ªçº¿ç¨‹åœ¨ä½¿ç”¨è¯¥é¡µã€‚ï¼ˆçœŸçš„æœ‰å†²çªå—ï¼Ÿï¼‰

éœ€è¦æ£€æŸ¥ï¼šsptlock, frame lock, filesys lock

æµ‹è¯•ï¼šä¸å¹¶è¡Œï¼Œé¡ºåºå››æ¬¡ linear æœ‰æ²¡æœ‰é—®é¢˜ï¼Ÿ  
- ä¸å¹¶è¡Œï¼Œé¡ºåºä¸¤æ¬¡ï¼Œä¼¼ä¹æ²¡ä»€ä¹ˆé—®é¢˜
- ä¸å¹¶è¡Œï¼Œé¡ºåºä¸‰æˆ–å››æ¬¡ï¼Œä¹Ÿå‡ºç°äº†æ±¡æŸ“ï¼
- è¿›ç¨‹é€€å‡ºæ—¶é‡ç½®å¸§ç³»ç»Ÿï¼ŒOKï¼
æ£€æŸ¥ exitï¼ï¼

page faultåŠ è½½çš„æ—¶å€™ä¼šåœ¨ pagedir é‡Œè®¾ç½®é¡µï¼Œåœ¨è¿›ç¨‹é€€å‡ºçš„æ—¶å€™ï¼Œ

# Lab 3b

**ä»»åŠ¡ 1ï¼šæ ˆå¢é•¿**
**ç»ƒä¹  1.1**

**å®ç°æ ˆå¢é•¿ã€‚**

åœ¨é¡¹ç›® 2 ä¸­ï¼Œç”¨æˆ·ç¨‹åºçš„æ ˆåªæ˜¯ä¸€é¡µï¼Œä½äºç”¨æˆ·è™šæ‹Ÿåœ°å€ç©ºé—´çš„æœ€é¡¶ç«¯ï¼Œå› æ­¤ç¨‹åºçš„æœ€å¤§æ ˆç©ºé—´è¢«é™åˆ¶ä¸º 1 é¡µã€‚

ç°åœ¨ï¼Œå¦‚æœæ ˆçš„ä½¿ç”¨è¶…è¿‡å½“å‰å¤§å°ï¼Œå°±è¦æ ¹æ®éœ€è¦åˆ†é…æ›´å¤šé¡µé¢ã€‚

* åªæœ‰åœ¨è®¿é—®â€œçœ‹èµ·æ¥åƒâ€æ ˆçš„åœ°å€æ—¶ï¼Œæ‰åˆ†é…é¢å¤–é¡µé¢ã€‚è¯·è®¾è®¡ä¸€ç§å¯å‘å¼æ–¹æ³•ï¼Œç”¨ä»¥åŒºåˆ†çœŸæ­£çš„æ ˆè®¿é—®å’Œå…¶ä»–è®¿é—®ã€‚

---

#### æ³¨æ„äº‹é¡¹

1. å¦‚æœç”¨æˆ·ç¨‹åºå¾€æ ˆæŒ‡é’ˆä»¥ä¸‹çš„ä½ç½®å†™æ•°æ®ï¼Œå°±å±äºç¨‹åºé”™è¯¯ã€‚å› ä¸ºå…¸å‹çš„æ“ä½œç³»ç»Ÿå¯èƒ½éšæ—¶ä¸­æ–­è¿›ç¨‹ä»¥ä¼ é€’â€œä¿¡å·â€ï¼Œè€Œä¿¡å·å¤„ç†ä¼šå‘æ ˆä¸­æ¨é€æ•°æ®ã€‚ä½† 80x86 æ¶æ„çš„ PUSH æŒ‡ä»¤ä¼šåœ¨è°ƒæ•´æ ˆæŒ‡é’ˆä¹‹å‰æ£€æŸ¥è®¿é—®æƒé™ï¼Œå› æ­¤å®ƒå¯èƒ½åœ¨æ ˆæŒ‡é’ˆä»¥ä¸‹ 4 å­—èŠ‚å¤„å¼•å‘ç¼ºé¡µå¼‚å¸¸ã€‚å¦åˆ™ï¼ŒPUSH æŒ‡ä»¤å°±ä¸èƒ½è¢«ç®€å•åœ°é‡å¯ã€‚åŒç†ï¼ŒPUSHA ä¸€æ¬¡æ€§å‘æ ˆé‡Œæ¨å…¥ 32 å­—èŠ‚ï¼Œæ‰€ä»¥å®ƒå¯èƒ½åœ¨æ ˆæŒ‡é’ˆä»¥ä¸‹ 32 å­—èŠ‚å¤„ç¼ºé¡µã€‚
2. åœ¨ç³»ç»Ÿè°ƒç”¨æˆ–ç”±ç”¨æˆ·ç¨‹åºå¼•å‘çš„ç¼ºé¡µå¼‚å¸¸å¤„ç†å‡½æ•°ï¼ˆ`syscall_handler()` æˆ– `page_fault()`ï¼‰ä¸­ï¼Œå¯ä»¥é€šè¿‡ä¼ å…¥çš„ `struct intr_frame` ç»“æ„çš„ `esp` æˆå‘˜è·å–å½“å‰ç”¨æˆ·æ ˆæŒ‡é’ˆå€¼ã€‚
3. å¦‚æœä½ åœ¨è®¿é—®ç”¨æˆ·å†…å­˜å‰å°±éªŒè¯äº†æŒ‡é’ˆï¼ˆå‚è§é¡¹ç›® 2 ä¸­â€œè®¿é—®ç”¨æˆ·å†…å­˜â€é‚£ä¸€èŠ‚ï¼‰ï¼Œé‚£ä¹ˆåªéœ€å¤„ç†ä¸Šè¿°æƒ…å†µã€‚
4. å¦‚æœä½ ä¾èµ–ç¼ºé¡µå¼‚å¸¸æ¥æ£€æµ‹éæ³•å†…å­˜è®¿é—®ï¼Œé‚£ä¹ˆè¿˜éœ€å¤„ç†å¦ä¸€ç§æƒ…å†µï¼šåœ¨å†…æ ¸ä¸­å‘ç”Ÿçš„ç¼ºé¡µã€‚è¿™æ˜¯å› ä¸ºå¤„ç†å™¨åªæœ‰åœ¨ä»ç”¨æˆ·æ¨¡å¼åˆ‡æ¢åˆ°å†…æ ¸æ¨¡å¼æ—¶æ‰ä¼šä¿å­˜ç”¨æˆ·æ ˆæŒ‡é’ˆåˆ° `intr_frame`ï¼Œæ­¤æ—¶ä» `intr_frame` è¯»å–åˆ°çš„ `esp` å€¼æ˜¯ä¸ç¡®å®šçš„ï¼Œå¹¶éç”¨æˆ·æ ˆæŒ‡é’ˆã€‚å› æ­¤ï¼Œéœ€è¦åœ¨æœ€åˆä»ç”¨æˆ·æ¨¡å¼è¿›å…¥å†…æ ¸æ—¶ï¼Œå°† `esp` ä¿å­˜åˆ° `struct thread` ä¸­ï¼Œæˆ–ä½¿ç”¨å…¶ä»–æ–¹æ¡ˆã€‚
5. ä½ åº”è¯¥å¯¹æ ˆå¤§å°è®¾å®šä¸€ä¸ªç»å¯¹é™åˆ¶ï¼Œå¤§å¤šæ•°æ“ä½œç³»ç»Ÿéƒ½ä¼šè¿™æ ·åšã€‚æœ‰äº›ç³»ç»Ÿå°†æ­¤é™åˆ¶è®¾ä¸ºå¯è°ƒèŠ‚ï¼ˆå¦‚ Unix ä¸‹çš„ `ulimit` å‘½ä»¤ï¼‰ã€‚åœ¨è®¸å¤š GNU/Linux ç³»ç»Ÿä¸­ï¼Œé»˜è®¤é™åˆ¶æ˜¯ 8â€¯MBã€‚
6. ç¬¬ä¸€é¡µæ ˆé¡µæ— éœ€å»¶è¿Ÿåˆ†é…â€”â€”å¯åœ¨åŠ è½½æ—¶å°±åˆ†é…å¹¶ç”¨å‘½ä»¤è¡Œå‚æ•°åˆå§‹åŒ–ã€‚
7. æ‰€æœ‰æ ˆé¡µéƒ½åº”å¯è¢«æ¢å‡ºï¼›æ¢å‡ºçš„æ ˆé¡µåº”å†™å…¥äº¤æ¢åŒºï¼ˆswapï¼‰ã€‚

---

**ä»»åŠ¡ 2ï¼šå†…å­˜æ˜ å°„æ–‡ä»¶**
**ç»ƒä¹  2.1**

æ–‡ä»¶ç³»ç»Ÿå¸¸ç”¨ `read` å’Œ `write` ç³»ç»Ÿè°ƒç”¨è¿›è¡Œè®¿é—®ã€‚å¦ä¸€ç§æ¬¡çº§æ¥å£æ˜¯ä½¿ç”¨ `mmap` ç›´æ¥å°†æ–‡ä»¶æ˜ å°„åˆ°è™šæ‹Ÿé¡µé¢ï¼Œç„¶åç¨‹åºå¯ç”¨æ™®é€šå†…å­˜æŒ‡ä»¤è®¿é—®æ–‡ä»¶æ•°æ®ã€‚

* è®¾æ–‡ä»¶ foo é•¿åº¦ä¸º 0x1000 å­—èŠ‚ï¼ˆ4â€¯KBï¼Œå³ä¸€é¡µï¼‰ã€‚è‹¥å°† foo æ˜ å°„åˆ°åœ°å€ 0x5000ï¼Œé‚£ä¹ˆå¯¹è™šæ‹Ÿåœ°å€ 0x5000â€¦0x5FFF çš„ä»»ä½•è®¿é—®ï¼Œéƒ½ä¼šå¯¹åº”æ–‡ä»¶ foo ä¸­çš„ç›¸åº”å­—èŠ‚ã€‚

ä¸‹é¢ç¤ºä¾‹ç¨‹åºä½¿ç”¨ `mmap` å°†æ–‡ä»¶æ‰“å°åˆ°æ§åˆ¶å°ï¼š

```c
#include <stdio.h>
#include <syscall.h>
int main (int argc UNUSED, char *argv[]) 
{
  void *data = (void *) 0x10000000;     /* æŒ‡å®šæ˜ å°„åœ°å€ */

  int fd = open (argv[1]);              /* æ‰“å¼€æ–‡ä»¶ */
  mapid_t map = mmap (fd, data);        /* æ˜ å°„æ–‡ä»¶ */
  write (1, data, filesize (fd));       /* å°†æ˜ å°„çš„æ•°æ®å†™åˆ°æ§åˆ¶å° */
  munmap (map);                         /* å–æ¶ˆæ˜ å°„ï¼ˆå¯é€‰ï¼‰ */
  return 0;
}
```

å®Œæ•´ç¤ºä¾‹ï¼ˆå«é”™è¯¯å¤„ç†ï¼‰çš„ `mcat.c` å’Œ `mcp.c` ä½äº examples ç›®å½•ä¸‹ã€‚

ä½ çš„å®ç°å¿…é¡»èƒ½å¤Ÿè·Ÿè¸ªå“ªäº›å†…å­˜åŒºåŸŸè¢«æ–‡ä»¶æ˜ å°„æ‰€å ç”¨ã€‚éœ€è¦ä¸€ä¸ªæ˜ å°„è¡¨æ¥è®°å½•æ–‡ä»¶ä¸è¿›ç¨‹è™šæ‹Ÿé¡µé¢çš„å¯¹åº”å…³ç³»ï¼Œä»¥ä¾¿ï¼š

1. åœ¨æ˜ å°„åŒºåŸŸå‘ç”Ÿç¼ºé¡µæ—¶æ­£ç¡®å¤„ç†ï¼›
2. ç¡®ä¿æ˜ å°„åŒºåŸŸä¸ä¸è¿›ç¨‹ä¸­å…¶ä»–æ®µï¼ˆå¦‚å¯æ‰§è¡Œæ–‡ä»¶åŠ è½½æ—¶çš„ä»£ç æ®µï¼æ•°æ®æ®µã€æ ˆç­‰ï¼‰é‡å ã€‚

---

#### ç»ƒä¹  2.1

**å®ç°å†…å­˜æ˜ å°„æ–‡ä»¶ï¼Œæ”¯æŒä»¥ä¸‹ç³»ç»Ÿè°ƒç”¨ï¼š**

* `mapid_t mmap (int fd, void *addr)`
* `void munmap (mapid_t mapping)`

##### ç³»ç»Ÿè°ƒç”¨ï¼š`mapid_t mmap (int fd, void *addr)`

1. å°†æ–‡ä»¶æè¿°ç¬¦ `fd` å¯¹åº”çš„å·²æ‰“å¼€æ–‡ä»¶æ˜ å°„åˆ°è¿›ç¨‹çš„è™šæ‹Ÿåœ°å€ç©ºé—´ã€‚æ•´ä¸ªæ–‡ä»¶åº”è¯¥æ˜ å°„åˆ°ä» `addr` å¼€å§‹çš„è¿ç»­è™šæ‹Ÿé¡µé¢ä¸Šã€‚
2. ä½ çš„è™šæ‹Ÿå†…å­˜ç³»ç»Ÿå¿…é¡»å®ç°â€œå»¶è¿ŸåŠ è½½â€â€”â€”å³åªæœ‰ç¬¬ä¸€æ¬¡è®¿é—®å¯¹åº”é¡µé¢æ—¶æ‰ä»æ–‡ä»¶ç³»ç»Ÿè¯»å–ï¼Œå¹¶ä¸”å°†è¯¥æ˜ å°„æœ¬èº«ä½œä¸ºé¡µé¢çš„åå°å­˜å‚¨ã€‚
3. ç½®æ¢ï¼ˆevictï¼‰æ˜ å°„é¡µé¢æ—¶ï¼Œåº”å°†ä¿®æ”¹è¿‡çš„é¡µé¢å†™å›æ˜ å°„æ–‡ä»¶ï¼›è‹¥æ–‡ä»¶é•¿åº¦ä¸æ˜¯æ•´æ•°é¡µï¼Œåˆ™æœ€åä¸€é¡µè¶…å‡ºæ–‡ä»¶æœ«å°¾çš„éƒ¨åˆ†ï¼Œåœ¨ç¼ºé¡µåŠ è½½æ—¶å°†å…¶ç½®ä¸º 0ï¼Œé¡µé¢å†™å›æ—¶èˆå¼ƒè¿™äº›éƒ¨åˆ†ã€‚
4. æ˜ å°„æˆåŠŸåˆ™è¿”å›å”¯ä¸€çš„â€œæ˜ å°„ IDâ€ï¼›å¤±è´¥åˆ™è¿”å› -1ï¼Œå¹¶ä¸”è¿›ç¨‹çš„æ˜ å°„å…³ç³»ä¸åº”è¢«ä¿®æ”¹ã€‚
5. ä»¥ä¸‹æƒ…å†µåº”å¯¼è‡´æ˜ å°„å¤±è´¥ï¼š

   * æ–‡ä»¶é•¿åº¦ä¸ºé›¶ï¼›
   * `addr` ä¸æ˜¯é¡µå¯¹é½ï¼›
   * æ˜ å°„åŒºåŸŸä¸ç°æœ‰ä»»ä½•æ˜ å°„æˆ–å…¶ä»–æ®µï¼ˆåŒ…æ‹¬æ ˆæˆ–å¯æ‰§è¡ŒåŠ è½½æ—¶æ˜ å°„ï¼‰é‡å ï¼›
   * `addr == 0`ï¼›
   * `fd` ä¸º 0 æˆ– 1ï¼ˆå®ƒä»¬åˆ†åˆ«æ˜¯æ ‡å‡†è¾“å…¥è¾“å‡ºï¼Œä¸èƒ½æ˜ å°„ï¼‰ã€‚

##### ç³»ç»Ÿè°ƒç”¨ï¼š`void munmap (mapid_t mapping)`

1. å–æ¶ˆç”± `mapping` æŒ‡å®šçš„æ˜ å°„ï¼Œè¯¥ ID å¿…é¡»æ˜¯æœ¬è¿›ç¨‹ä¹‹å‰æˆåŠŸè¿”å›ä¸”å°šæœªå–æ¶ˆæ˜ å°„çš„æ˜ å°„ã€‚
2. è¿›ç¨‹é€€å‡ºæ—¶ï¼ˆæ— è®ºæ˜¯æ­£å¸¸é€€å‡ºè¿˜æ˜¯å¼‚å¸¸ç»ˆæ­¢ï¼‰ï¼Œæ‰€æœ‰æ˜ å°„éƒ½åº”è‡ªåŠ¨å–æ¶ˆã€‚
3. å–æ¶ˆæ˜ å°„æ—¶ï¼Œæ‰€æœ‰è¢«å†™è¿‡çš„é¡µé¢å†™å›æ–‡ä»¶ï¼Œæœªè¢«å†™çš„é¡µé¢ä¸å†™ï¼›ç„¶åå°†è¿™äº›é¡µé¢ä»è¿›ç¨‹çš„é¡µè¡¨å’Œæ˜ å°„è¡¨ä¸­ç§»é™¤ã€‚
4. å…³é—­æˆ–åˆ é™¤æ–‡ä»¶å¹¶ä¸è‡ªåŠ¨å–æ¶ˆæ˜ å°„ï¼›æ˜ å°„åœ¨è°ƒç”¨ `munmap` å‰å§‹ç»ˆä¿æŒæœ‰æ•ˆï¼ˆç¬¦åˆ Unix çº¦å®šï¼‰ã€‚å¯¹åŒä¸€æ–‡ä»¶çš„æ¯ä¸ªæ˜ å°„éƒ½åº”è°ƒç”¨ `file_reopen` è·å–ç‹¬ç«‹çš„æ–‡ä»¶å¼•ç”¨ã€‚
5. è‹¥å¤šä¸ªè¿›ç¨‹æ˜ å°„åŒä¸€æ–‡ä»¶ï¼Œä¸å¿…ä¿è¯å„è‡ªçœ‹åˆ°ä¸€è‡´æ•°æ®ï¼›Unix é€šè¿‡è®©å®ƒä»¬å…±äº«åŒä¸€ç‰©ç†é¡µé¢æ¥å¤„ç†ï¼Œè€Œ `mmap` ç³»ç»Ÿè°ƒç”¨è¿˜èƒ½è®©ç”¨æˆ·é€‰æ‹©â€œå…±äº«â€æˆ–â€œç§æœ‰â€ï¼ˆå†™æ—¶å¤åˆ¶ï¼‰æ˜ å°„ã€‚

ä¸ºä»€ä¹ˆåœ¨ syscall ä¸­è®¿é—® intr_frame->esp å¯èƒ½æ˜¯æœªå®šä¹‰çš„ï¼Ÿ

ğŸ“š èƒŒæ™¯çŸ¥è¯†
1. intr_frame æ˜¯ä»€ä¹ˆï¼Ÿ
å½“ç”¨æˆ·ç¨‹åºå‘ç”Ÿä¸­æ–­ï¼ˆæ¯”å¦‚ç³»ç»Ÿè°ƒç”¨æˆ–ç¼ºé¡µï¼‰æ—¶ï¼ŒPintos å†…æ ¸ä¸ºè¯¥ä¸­æ–­åˆ›å»ºä¸€ä¸ª struct intr_frameï¼Œå®ƒä¿å­˜äº†å½“æ—¶çš„ CPU å¯„å­˜å™¨çŠ¶æ€ï¼ˆåŒ…æ‹¬ eip, esp, eax ç­‰ï¼‰ï¼Œä»¥ä¾¿ä¸­æ–­å¤„ç†å®Œæ¯•åèƒ½â€œæ¢å¤â€ç”¨æˆ·ç¨‹åºçš„æ‰§è¡Œã€‚

2. ä»€ä¹ˆæ—¶å€™ esp æ˜¯å¯é çš„ï¼Ÿ
å½“ä¸­æ–­ä»ç”¨æˆ·æ€è¿›å…¥å†…æ ¸æ€æ—¶ï¼ŒCPU ä¼šè‡ªåŠ¨æŠŠç”¨æˆ·æ€çš„ espï¼ˆç”¨æˆ·æ ˆæŒ‡é’ˆï¼‰å‹å…¥å†…æ ¸æ ˆä¸­ï¼Œæ‰€ä»¥ intr_frame->esp å°±æ˜¯å½“æ—¶çš„ç”¨æˆ·æ ˆæŒ‡é’ˆ â€”â€” æ˜¯æœ‰æ„ä¹‰çš„ï¼

â—ä½† syscall çš„éæ³•å†…å­˜å¼•ç”¨æ˜¯ä¸ªç‰¹ä¾‹
åœ¨ Pintos ä¸­ï¼š

syscall_handler() æ˜¯å¤„ç†ç³»ç»Ÿè°ƒç”¨çš„å‡½æ•°ï¼›

ç³»ç»Ÿè°ƒç”¨æ˜¯é€šè¿‡ int 0x30 å®ç°çš„ï¼Œå®ƒè§¦å‘ä¸€ä¸ªè½¯ä¸­æ–­ï¼›

å½“ç³»ç»Ÿè°ƒç”¨è¿›å…¥å†…æ ¸æ€æ—¶ï¼ŒPintos ä¹Ÿç¡®å®é€šè¿‡ intr_frame å¾—åˆ°äº†ç”¨æˆ·çš„å¯„å­˜å™¨å€¼ï¼ˆåŒ…æ‹¬ espï¼‰ï¼›

ä½†æ˜¯ï¼ å¦‚æœç”¨æˆ·ç¨‹åºä¼ å…¥äº†ä¸€ä¸ªéæ³•åœ°å€ï¼ˆæ¯”å¦‚ sys_write(1, (void*)0x12345678, 10)ï¼ŒæŒ‡å‘äº†æ— æ•ˆå†…å­˜ï¼‰ï¼Œç„¶å Pintos å†…æ ¸åœ¨æ²¡æœ‰åšæ£€æŸ¥çš„æƒ…å†µä¸‹è®¿é—®äº†è¿™ä¸ªåœ°å€â€”â€”

âš ï¸ é”™è¯¯è®¿é—®ä¸ä¼šå†è§¦å‘ç”¨æˆ·æ€çš„ page faultï¼Œè€Œæ˜¯ï¼š
åœ¨å†…æ ¸æ€è§¦å‘äº† page faultï¼›

è¿™æ—¶è¿›å…¥ page_fault()ï¼Œä½†æ³¨æ„ï¼š

CPU ä¸ä¼šä¿å­˜åŸæœ¬çš„ç”¨æˆ· espï¼Œå› ä¸ºç°åœ¨å‡ºé”™å‘ç”Ÿåœ¨å†…æ ¸æ€ï¼

æ‰€ä»¥è¿™æ—¶å€™çš„ intr_frame->espï¼š

æ˜¯å†…æ ¸æ€çš„ espï¼Œä¸æ˜¯ç”¨æˆ·æ€çš„ï¼

æ‰€ä»¥å®ƒçš„å€¼å¯¹â€œåˆ¤æ–­æ ˆè®¿é—®æ˜¯å¦åˆæ³•â€æ˜¯æ— æ•ˆ/æœªå®šä¹‰çš„ï¼›

å¦‚æœä½ åœ¨ page_fault() ä¸­ä½¿ç”¨äº†è¿™ä¸ª esp æ¥å†³å®šæ˜¯å¦æ˜¯â€œæ ˆå¢é•¿â€è®¿é—®ï¼Œå°±ä¼šåˆ¤æ–­é”™è¯¯ï¼Œç”šè‡³å‡ºé”™ã€‚

âœ… æ­£ç¡®çš„åšæ³•
ä¸ºäº†å¯é è·å–â€œè¿›å…¥å†…æ ¸ä¹‹å‰çš„ç”¨æˆ·æ ˆæŒ‡é’ˆâ€ï¼Œä½ éœ€è¦åœ¨è¿›å…¥å†…æ ¸çš„æœ€åˆæ—¶åˆ»ï¼Œä¹Ÿå°±æ˜¯åœ¨ syscall_handler() å¼€å¤´ï¼Œä¸»åŠ¨æŠŠ intr_frame->esp ä¿å­˜ä¸‹æ¥ï¼Œä¾‹å¦‚ï¼š

c
å¤åˆ¶
ç¼–è¾‘
struct thread *t = thread_current();
t->user_esp = f->esp;  // f æ˜¯ syscall_handler çš„ intr_frame* å‚æ•°
ä¹‹åå³ä½¿å‘ç”Ÿ page fault æ—¶ intr_frame->esp ä¸å¯é ï¼Œä¹Ÿå¯ä»¥ä» thread_current()->user_esp è·å–å½“æ—¶çš„ç”¨æˆ·æ ˆæŒ‡é’ˆã€‚

- Test robustness of "mmap" system call.
   1/ 1 tests/vm/mmap-bad-fd
   1/ 1 tests/vm/mmap-inherit
** 0/ 1 tests/vm/mmap-null
   1/ 1 tests/vm/mmap-zero

** 0/ 2 tests/vm/mmap-misalign

** 0/ 2 tests/vm/mmap-over-code
** 0/ 2 tests/vm/mmap-over-data
** 0/ 2 tests/vm/mmap-over-stk
** 0/ 2 tests/vm/mmap-overlap